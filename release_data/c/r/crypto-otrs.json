{
    "1.0.0": {
        "info": {
            "author": "",
            "author_email": "One Time Traceable Ring Signature <truestop16@gmail.com>",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Programming Language :: Python",
                "Programming Language :: Python :: 3"
            ],
            "description": "# crypto-otrs: One-time Traceable Ring Signature\n```\npip3 install crypto-otrs\n```\n\n\nBased on the [the work of Alessandra Scafuro and Bihan Zhang](https://eprint.iacr.org/2021/1054.pdf) of the Nord Carolina State University.  \nUse this at your own risk. This is a python library that wraps the C code you can find at my github [github.com/NickP005/my-cryptography](https://github.com/NickP005/my-cryptography). \nQuantum-resistant, speedy, black-box, random oracle\n\n## What is a ring signature\nA ring signature is a cryptographic signature scheme that can be signed by any member of a group of users (AKA \"ring\"). The signer produces a signature on the message that proves the message has been signed by one of the group members, but it is impossible to know certainly who.\n    \nFor example: during the meeting of Pear's shareholders (Luca, Matteo and Lucia), each shareholder is asked to vote anonymously on the increase in payrool of the employees. Looking just to Luca (but the other members will do the same): Luca generates a keypair and publishes it to the world. Then, after Luca gets Matteo and Lucia's ones, he makes signs the message \"I approve to increase payrool at date XX/XX/XXXX\" on behalf of the ring of public keys (Luca, Matteo, Lucia). Then they anonymously submit the signatures to a notary that looking at the signature, cannot deduce anything except that the signer could be with equal probability Luca as well as Matteo as well as Lucia.  \nThis scheme is traceable in the sense that if Matteo wanted to cheat (give more weight to his opinion) and signs 2 messages, the notary will be able to trace back, given the 2 messages, to Matteo's public key.\n\nPay attention that the public/private keypair is throwaway and **must be used once** (recall: one time). Only one message is signable at time.\n\n## How to use\nBelow some example usage\n\n### Create a keypair\n```\nfrom crypto-otrs import ring\n\npublic_key, private_key = ring.keygen()\n```\n\n### Sign a message\n```\nfrom crypto-otrs import ring\n\nbob_public, bob_private = ring.keygen()\nalice_public, alice_private = ring.keygen()\n\nring = []\nring.append(bob_public)\nring.append(alice_public)\n\n# here Alice signs pasta vs pizza feud\n# position of Alice's public key is 1\nalice_signature = ring.RSign(ring, alice_private, 1, b\"pizza is the besta food of the world\")\n```\n\n### Verify a signature\nnow someone gets a \"signature\", the public keys (MUST BE IN ORDER!) of it and the message:\n```\nfrom crypto-otrs import ring\n\nis_valid = ring.RVer(ring, b\"pizza is the besta food of the world\", signature) \n# --> True or False\n```\n\n### Trace a signature\nWe don't know if Bob voted yet or is still playing video games, but we got 2 signatures... let's check if Alice cheated (Alice likes to cheat often):\n```\nfrom crypto-otrs import ring\n\nis_from_same_signer, traced_public_key = ring.RTrace(ring, signature_1, signature_2)\n# --> True, alice_public\n# ...Alice cheated\n```\n\n## Technical overview\n### keygen() \n`public_key[768], private_key[512] = ring.keygen()`  \nreturns a public/private keypair tuple stored in the form of uint_8 arrays.\n### RSign() \n`signature[SIG_LEN] = ring.RSign(ring, private_key, position, message)`  \nwhere `SIG_LEN = N*256 + N*16`  \ngenerates a signature in the form of a uint_8 array. Takes in the array of public keys of the ring, the private key, the position of the public key in the ring (start from 0) and a message that should be in the form of bytes.\n### RVer() \n`is_valid = RVer(ring, message, signature)`  \noutputs `True` when the signature is valid, `False` otherwise.  \nTakes in the array of public keys (ring), the message (as said before, in bytes) and the signature.\n### RTrace() \n`traces, traced = RTrace(ring, signature_1, signature_2)`  \noutputs a tuple where the first element is a boolean that outputs `True` when the two signatures came from the same private key. In this case the `traced` variable is equal to the public key of the traced signature.\n\n## Performance\nI didn't test python ones, since it is a wrapper, should be te same as [github.com/NickP005/my-cryptography](https://github.com/NickP005/my-cryptography)\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "",
            "keywords": "cryptography,ring,signature,otrs,quantum-resistant",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "crypto-otrs",
            "package_url": "https://pypi.org/project/crypto-otrs/",
            "platform": null,
            "project_url": "https://pypi.org/project/crypto-otrs/",
            "project_urls": {
                "Homepage": "https://github.com/NickP005/my-cryptography"
            },
            "release_url": "https://pypi.org/project/crypto-otrs/1.0.0/",
            "requires_dist": [
                "black ; extra == 'dev'",
                "bumpver ; extra == 'dev'",
                "isort ; extra == 'dev'",
                "pip-tools ; extra == 'dev'",
                "pytest ; extra == 'dev'"
            ],
            "requires_python": ">=3.6.9",
            "summary": "One-time Traceable Ring Signature of Alessandra Scafuro and Bihan Zhang implemented by @NickP05",
            "version": "1.0.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16274739,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "47f123a65b98b6fc6f823402f17c3873",
                    "sha256": "1b8e64c6333d997d1479b8add7cd53235a97634b16ae400f18d9d98e0113653b"
                },
                "downloads": -1,
                "filename": "crypto_otrs-1.0.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "47f123a65b98b6fc6f823402f17c3873",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.6.9",
                "size": 5142,
                "upload_time": "2023-01-01T23:04:34",
                "upload_time_iso_8601": "2023-01-01T23:04:34.134168Z",
                "url": "https://files.pythonhosted.org/packages/96/a2/6c4fd491e1434882c08ebff012b99eb62471515673f1f2abc84e32b017f3/crypto_otrs-1.0.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}