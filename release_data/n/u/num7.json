{
    "1.0.15": {
        "info": {
            "author": "giocip",
            "author_email": "giocip7@gmail.com",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3.10"
            ],
            "description": "# SUPREME PRECISION GENERAL PURPOSE DECIMAL ARITHMETIC-LOGIC CLASS\r\n## _DESCRIPTION AND DOC_\r\n\r\nNum is a lightweight floating point numeric class for arbitrary precision results with always supreme precision.\r\n\r\nEasy to use like school math and WITHOUT IEEE754 ISSUES or +0 AND -0 FAILURES, it can be deployed  \r\nfor web e-commerce developing, accounting apps and general math programs included financial ones.\r\n\r\n## HOW TO USE (integer numeric strings (ex. '2.0') MUST BE SUFFIXED WITH .0):\r\n--- CALCULATOR MODE ---  \r\n\r\n\t                   >>> from num7 import Num, Num as calc  \r\n\tADDITION:          >>> calc.add('-5.3', '2.1')    # Num('-3.2')  \r\n\tSUBTRACTION:       >>> calc.sub('-5.3', '2.1')    # Num('-7.4')  \r\n\tMULTIPLICATION:    >>> calc.mul('-5.3', '2.1')    # Num('-11.13')  \r\n\tDIVISION:          >>> calc.div('-5.3', '2.1')    # Num('-2.52380952380952380952380952380952380952380952380952380952380952380952380952380952')  \r\n\tM+:                >>> M = calc('0.0'); M.inc('3.0'); M.inc('3.3'); M.inc('3.7'); print(M) # 10.0  \r\n\tM-:                >>>                  M.dec('5.0'); M.dec('3.3'); M.dec('1.5'); print(M) # 0.2  \r\n\tMC:                >>> M.clear(); print(M) # 0.0  \r\n\tINT   DIV AND REM: >>> calc.divmod('5.0', '3.0')  # (Num('1.0'), Num('2.0')) => tuple  \r\n\tFLOAT DIV AND REM: >>> calc.divmod('5.2', '3.1')  # (Num('1.0'), Num('2.1')) => tuple  \r\n\tPOWER:             >>> calc.pow('-5.3', '2.0')    # Num('28.09')  \r\n\tSQRT:              >>> calc.sqrt('2.0')           # Num('1.41421356237309504880168872420969807856967187537694807317667973799073247846210703')  \r\n\tROUND:             >>> calc.sqrt('2.0').round(2)  # Num('1.41')  \r\n\tABSOLUTE VALUE     >>> calc.abs('-3.0')           # Num('3.0')  \r\n\tSUM:               >>> cart = ['19.32','18.37','15.13']; calc.sum(*cart)          # Num('52.82')  \r\n\tMEAN:              >>> cart = ['19.32','18.37','15.13']; calc.mean(*cart).round() # Num('17.61')  \r\n\tMIN:               >>> cart = ['19.32','18.37','15.13']; calc.min(cart)           # Num('15.13')  \r\n\tMAX:               >>> cart = ['19.32','18.37','15.13']; calc.max(cart)           # Num('19.32')  \r\n\tEXP:               >>> calc.mul('-5.3e1024', '2.1e1024').num2exp()                # '-1113E2046'  \r\n\tREPL:              >>> a = calc('0.1'); b = calc('0.2'); print(calc.add(a, b))    # 0.3  \r\n\r\n## CODING:  \r\n\t>>> from num7 import Num, Num as calc\r\n\r\n(=) assignment:  \r\n\r\n\t>>> a = Num('3.0'); b = Num('5.0'); c = Num('0.0'); #  \r\n\t>>> print('a =', a, 'b =', b, 'c =', c) # a = 3.0 b = 5.0 c = 0.0  \r\n\r\n(+) adding:  \r\n\r\n\t>>> R = a+b+c; print(R) # 8.0  \r\n\t>>> a = Num('0.1'); b = Num('0.2'); c = Num('0.0'); print(a+b+c) # 0.3  \r\n\r\n(-) subtracting:  \r\n\r\n\t>>> a = Num('0.1'); b = Num('0.2'); c = Num('0.3');  \r\n\t>>> print(a+b-c) # 0.0  \r\n\t>>> R = Num('-3.99') - Num('-5.20') - Num('+3.01'); print(R) # -1.8  \r\n\r\n(*) multiplying:  \r\n\r\n\t>>> Num('-3.99') * Num('-5.20') * Num('+3.01') # -3.99 * (-5.20) * (+3.01 ) = Num('62.45148')  \r\n\r\n(/) dividing (80 decimal digits default gets only for division operation):  \r\n\r\n\t>>> Num('3.0') / Num('5.7') # 3 : 5.7 = Num('0.52631578947368421052631578947368421052631578947368421052631578947368421052631578')  \r\n\r\nDivision precision (ex. 128 decs) may be specified as parameter after numeric string as: \r\n \t    \r\n\t>>> Num('3.0', 128) / Num('5.7', 128) # 3 : 5.7 = Num('0.52631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052631578947368421052')  \r\n\r\n(// % operators, divmod python3 built-in function) int division and remainder:  \r\n\r\n\t>>> a = Num('5.0'); b = Num('2.0') #  \r\n\t>>> Q = a // b; R = a % b; print('Quotient =', Q, 'Remainder =', R) # Quotient = 2.0 Remainder = 1.0  \r\n\t>>> a = Num('15.0'); b = Num('4.0') #  \r\n\t>>> Q, R = divmod(a, b); print('Quotient =', Q, 'Remainder =', R)   # Quotient = 3.0 Remainder = 3.0  \r\n\r\n(divmod python3 built-in function) floating division and remainder:  \r\n\r\n\t>>> a = Num('10.123456789'); b = Num('2.0') #  \r\n\t>>> Q, R = divmod(a, b); print('Quotient =', Q, 'Remainder =', R)   # Quotient = 5.0 Remainder = 0.123456789  \r\n\r\n(sqrt) square root function:  \r\n\r\n\t>>> a = Num('123_456_789.1234567890123456789'); root = a.sqrt() # Num('11111.11106611111096998611053449930232404576951925017079015206589094347963821409843324')  \r\n\t>>> print('result digits number tuple =>', root.len()) # result digits number tuple => (5, 80)  \r\n\r\n(**) power operator and pow python3 built-in function:  \r\n\r\n\t>>> a = Num('2.22123') ** 64; print(a) # 15204983311631674774944.65147209888660757554174463321311015807893679105748958794491681177995203669698667160837739445605536688871012507194541849848681968140805876570485027380472936734094801420552285940765338219588362327695177798251793912104057999943308320501195784173135380826413054938730768027747418766018606636039075568645106645889100039914241  \r\n\t>>> print(a.len()) # (23, 320) digits len tuple  \r\n\t>>> print(Num(Num.pi))  # 3.141592654  \r\n\t>>> pow(Num(Num.pi), 8) # Num('9488.531025982131642534428505085353941520356351078169077371202330414440366336')  \r\n\r\nlogic (in, not in, is, is not, <, <=, >, >=, !=, ==) and relational operators (and, or, not).  \r\n\r\n(in):  \r\n\r\n\t>>> L = [Num('0.1'), Num('1.0'), Num('5.5'), Num('-3.0'), Num('-2.9'), Num('-3.0001'), Num('2.2')]  \r\n\t>>> Num('-3.0001') in L; Num('-3.00001') in L         #True False  \r\n\r\n(not in):  \r\n\r\n\t>>> Num('-3.0001') not in L; Num('-3.00001') not in L #False True  \r\n\r\n(is, is not):  \r\n\r\n\t>>> M = calc('0.0'); Num('0.0') is M # False  \r\n\t>>> M = calc('0.0'); M.inc('0.1') is not M; M # True Num('0.1')  \r\n\t>>> M; N = M; N.dec('0.1'); N is M; M; N # Num('0.1') True Num('0.0') Num('0.0')  \r\n\r\n(< <= > >= != ==)  \r\n\r\n\t>>> a = Num('0.0'); b = Num('0.1'); c = Num('-0.2')  \r\n\t>>> a <  b; a <  c; b <  c #True  False False  \r\n\t>>> a <= a; a <= c; b <= c #True  False False  \r\n\t>>> a >  b; a >  c; b >  c #False True  True  \r\n\t>>> a >= a; a >= c; b >= c #True  True  True  \r\n\t>>> c == -2*b; a == c + 2*b ; a != a+b+c #True  True  True  \r\n\t>>> a and b; a or b; not a     # Num('0.0') Num('0.1') True  \r\n\t>>> True if a and b else False # False  \r\n\t>>> True if a or  b else False # True  \r\n\r\n(+ - unary operators)\r\n  \r\n\t>>> Num('+2.5521') # Num('2.5521')  \r\n\t>>> Num('-3.3321') # Num('-3.3321')  \r\n\t>>> Num('+2.5521') + Num('-3.3321') # Num('-0.78')  \r\n\r\n# Advanced logic programming snippet\r\n\r\nLOOP EXAMPLE >>>  \r\n\r\n\tfrom num7 import Num  \r\n\ti = Num(0)  \r\n\twhile i < Num('1.0'):  \r\n\t\ti.inc('0.1') #i += Num('0.1')  \r\n\t\tif i <= Num('0.5'):  \r\n\t\t\tcontinue  \r\n\t\tprint(i) #0.6, 0.7, 0.8, 0.9, 1.0  \r\n\twhile i:  \r\n\t\ti.dec('0.1') #i -= Num('0.1')  \r\n\t\tif i >= Num('0.5'):  \r\n\t\t\tcontinue  \r\n\t\tprint(i) #0.4 0.3 0.2 0.1 0.0  \r\n\r\nROUNDING AND ACCOUNTING >>>  \r\n\r\n\tfrom num7 import Num   \r\n\tp = Num('11.19')               #PRICE -Toslink cable for soundbar  \r\n\tpd = round(p.f_price_over(-7)) #PRICE DISCOUNTED 7%  \r\n\td = round(p - pd)              #DISCOUNT  \r\n\tp_noTAX = round(p.f_price_spinoff(22)) #COST ITEM WITHOUT TAX 22%  \r\n\tTAX = round(p - p_noTAX)               #TAX 22%  \r\n\tprint(F'price={p} PAYED={pd} discount={d} COST={p_noTAX} TAX={TAX}') #price=11.19 PAYED=10.41 discount=0.78 COST=9.17 TAX=2.02  \r\n\r\nPERFORMANCE EVALUATION AND SQUARENESS >>>  \r\n\t\r\n\tfrom num7 import Num  \r\n\tfrom time import perf_counter  \t\r\n\ttic = perf_counter() # Start Time  \r\n\ta = Num('-1.123456789'+'e-100')      #calculating division 10**100...  \r\n\ttoc = perf_counter() # End Time  \r\n\tT1 = toc - tic  \r\n\tprint(f\"a finished sec. {T1:1.6f}\")  \r\n\ttic = perf_counter() # Start Time  \r\n\tb = ('-1.123456789') >> Num('100.0') #calculating division 10**100...  \r\n\ttoc = perf_counter() # End Time  \r\n\tT2 = toc - tic  \r\n\tprint(f\"b finished sec. {T2:1.6f}\")  \r\n\tR = Num.f_perf_time(str(T1), str(T2))  \r\n\tprint('PCT=>', R[0].round(), 'SCALE=>', R[1].round(), 'SQUARENESS=>', a == b) # PCT= -98.6 SCALE= -70.47 SQUARENESS=> True  \r\n\r\nSCIENTIFIC NOTATION AND HIGH PRECISION RESULTS >>>\r\n\r\n\tfrom num7 import Num    \r\n\ta = Num('1_000_000_000_000_000_000_000.0') #standard notation  \r\n\tb = Num('1e21') #scientific notation  \r\n\tSUM = a + b #SUM  \r\n\tieee754 = float(a)+float(b)  \r\n\tprint('SUM == ieee754', SUM == Num(str(ieee754)), ' SUM =>', SUM.num2exp()) #SUM == ieee754 True  SUM => 2e21  \r\n\t\r\n\ta = Num('1_000_000_000_000_000_000_000.0') #standard notation  \r\n\tb = Num('1e21') #scientific notation  \r\n\tMUL = a * b #MUL  \r\n\tieee754 = float(a)*float(b)  \r\n\tprint('MUL == ieee754', MUL == Num(str(ieee754)), ' MUL =>', MUL.num2exp()) #MUL == ieee754 True  MUL => 1e42  \r\n\t\r\n\ta = '1.23456789'  \r\n\tb = '9.87654321'  \r\n\tMUL = Num(a) * Num(b) #MUL  \r\n\tieee754 = float(a)*float(b)  \r\n\tprint('MUL == ieee754', MUL == Num(str(ieee754)), 'MUL =>', MUL, float(a)*float(b), '=> IEEE754 PRECISION FAILURE!') #MUL == ieee754 False MUL => 12.1932631112635269 12.193263111263525 => IEEE754 PRECISION FAILURE!  \r\n\t\r\n\ta = '1.23456789e320' #scientific notation  \r\n\tb = '9.87654321e320'  \r\n\tMUL = Num(a) * Num(b) #MUL  \r\n\tieee754 = float(a)*float(b)  \r\n\tprint('MUL == ieee754', MUL.str() == str(ieee754), 'MUL =>', MUL.num2exp(), float(a)*float(b), '=> IEEE754 inf FAILURE!') #MUL == ieee754 False MUL => 121932631112635269e624 inf => IEEE754 inf FAILURE!  \r\n\t\r\n\ta = '2e320' #scientific notation  \r\n\tb = '3e-320'  \r\n\tMUL = Num(a) * Num(b) #MUL  \r\n\tieee754 = float(a)*float(b)  \r\n\tprint('MUL == ieee754', MUL.str() == str(ieee754), 'MUL =>', MUL.num2exp(), ieee754, '=> IEEE754 inf FAILURE!') #MUL == ieee754 False MUL => 6.0 inf => IEEE754 inf FAILURE!  \r\n\t\r\n\ta = '1e200' #scientific notation  \r\n\tb = '5e1200'  \r\n\tT1 = Num(a, 1200) #ultra precision (over 80 digits default) floating point division must be specified!  \r\n\tT2 = Num(b)  \r\n\tDIV = T1 / T2 #DIV  \r\n\tieee754 = float(a)/float(b)  \r\n\tprint('DIV == ieee754', DIV.str() == str(ieee754), 'DIV =>', DIV.num2exp(), ieee754, '=> IEEE754 precision FAILURE!') #DIV == ieee754 False DIV => 2e-1001 0.0 => IEEE754 precision FAILURE!  \r\n\r\nFLOAT TO NUM CONVERSION LIST >>>\r\n\r\n\tfrom num7 import Num  \r\n\tL = [1011, 0.0, 9.998412, 7.0, 0.123, -2.0123, 10, 6]\r\n\tLN= Num.float2num_list(L)\r\n\tprint(list(i.n for i in LN)) #['1011.0', '0.0', '9.998412', '7.0', '0.123', '-2.0123', '10.0', '6.0']\r\n\tprint(list(i for i in LN))   #[Num('1011.0'), Num('0.0'), Num('9.998412'), Num('7.0'), Num('0.123'), Num('-2.0123'), Num('10.0'), Num('6.0')]\r\n\r\nSAVE NUMERIC LIST TO DISK FILE >>>\r\n\r\n\tNum.f_filewrite(L) #\r\n\r\nREAD NUMERIC LIST FROM DISK FILE (nums.txt default filename) >>>\r\n\r\n\tL = Num.f_fileread(); print(L) #[Num('1011.0'), Num('0.0'), Num('9.998412'), Num('7.0'), Num('0.123'), Num('-2.0123'), Num('10.0'), Num('6.0')]\r\n\r\n### FAQ \r\n\r\nQ. I usually try to add 0.1 to 0.2 in python3 with this code:  \r\n\r\n\t>>> print(0.1 + 0.2)  \r\nand the result is:  \r\n\r\n\t>>> 0.30000000000000004  \r\n\t\r\nHow instead can it gets exactly 0.3?  \r\nA. Using Num class >>>  \r\n\r\n\tfrom num7 import Num, Num as calc  \r\n\tprint(Num('0.1') + Num('0.2'))  #calc.add('0.1', '0.2') #0.3  \r\n\r\nQ. I'll get an arror when i usually type:  \r\n\t\r\n\t>>> Num(0.1)    \r\n \r\n\tTraceback (most recent call last):  \r\n\tFile \"<pyshell>\", line 1, in <module>  \r\n\tFile \"C:\\Users\\pincopallino\\mydata\\Python\\Python310\\lib\\site-packages\\num7.py\", line 470, in __init__  \r\n\t\traise ValueError(F\"Num.__init__ => float, type not valid: {n}\")  \r\n\tValueError: Num.__init__ => float, type not valid: 1.0\t\r\n\t\r\nWhat is wrong?  \r\nA. You must use quotes or string conversion with built-in str function:\r\n\r\n\t>>> from num7 import Num   \r\n\t>>> Num('0.1')    #Num('0.1')  \r\n\t>>> Num(str(0.1)) #Num('0.1')  \r\n\r\nQ. How can i convert a regular float to a Decimal?\r\nA. With Num.ieee754() method >>>  \r\n\r\n\tfrom num7 import Num, Num as calc  \r\n\ta=0.1; b=0.2;  \r\n\tc=a+b #0.30000000000000004 => PRECISION FAILURE!  \r\n\tan = Num.ieee754(a); print(an)     #0.1000000000000000055511151231257827021181583404541015625  \r\n\tbn = Num.ieee754(b); print(bn)     #0.200000000000000011102230246251565404236316680908203125  \r\n\tcn = Num.ieee754(a+b);  \r\n\tprint(cn, '=> PRECISION FAILURE!') #0.3000000000000000444089209850062616169452667236328125 => PRECISION FAILURE!  \r\n\tT = calc.add(an, bn)  \r\n\tprint(T, '=> OK.')                 #0.3000000000000000166533453693773481063544750213623046875 => OK.  \r\n\r\nQ. I have two float variables in my code:  \r\n\r\n\t>>> a = 0.1; b = 0.2  \r\n\t\r\nHow can i convert them in Num type?  \r\nA. With Num.float2num method (or directly with str() bult-in function) >>>  \r\n\r\n\tfrom num7 import Num  \r\n\ta = 0.1; b = 0.2 #  \r\n\tan= Num.float2num(a); bn= Num.float2num(b) #an= Num(str(a)); bn= Num(str(b))  \r\n\tprint(an+bn, 'OK. VS', a+b, 'PRECISION FAILURE!') #0.3 OK. VS 0.30000000000000004 PRECISION FAILURE!  \r\n\r\nQ. Can i do add or other math operations also with 10_000 digits after floating point?  \r\nA. Yes, you can. >>>\r\n\r\n\tfrom num7 import Num  \r\n\tprint((Num('1.123456789e-10_000') + Num('3.987654321e-10_000')).num2exp()) #511111111e-10008  \r\n\tprint((Num('1.123456789e-10_000') - Num('3.987654321e-10_000')).num2exp()) #-2864197532e-10009  \r\n\tprint((Num('1.123456789e-10_000') * Num('3.987654321e-10_000')).num2exp()) #4479957319112635269e-20018  \r\n\tprint((Num('1.123456789e-10_000') / Num('3.987654321e-10_000'))) #0.28173374584742497292307298769992856660154820877213142969420392746224704666420356  \r\n\r\n\r\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/giocip/num7",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "num7",
            "package_url": "https://pypi.org/project/num7/",
            "platform": null,
            "project_url": "https://pypi.org/project/num7/",
            "project_urls": {
                "Homepage": "https://github.com/giocip/num7"
            },
            "release_url": "https://pypi.org/project/num7/1.0.15/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "Num - SUPREME PRECISION GENERAL PURPOSE DECIMAL ARITHMETIC-LOGIC CLASS",
            "version": "1.0.15",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16063751,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "440d08bf15e3ec104293f920d144799a",
                    "sha256": "785b94f7eadf3d29923f43c0c41d9e162e7c773ee8bc4a32597974a21f13300f"
                },
                "downloads": -1,
                "filename": "num7-1.0.15-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "440d08bf15e3ec104293f920d144799a",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 18581,
                "upload_time": "2022-12-11T09:48:18",
                "upload_time_iso_8601": "2022-12-11T09:48:18.947390Z",
                "url": "https://files.pythonhosted.org/packages/f5/61/c8b25d0ca53119c2e71b8f18ea800cf12677555d6fbfc61d89307e7c0c34/num7-1.0.15-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "81c2be8a8eb3948e1eb3607d3b7b90d5",
                    "sha256": "72b89ab703c519a0a3ea543d97d1a63d29b1ed46b2b8cb5255d522af794a8d32"
                },
                "downloads": -1,
                "filename": "num7-1.0.15.tar.gz",
                "has_sig": false,
                "md5_digest": "81c2be8a8eb3948e1eb3607d3b7b90d5",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": null,
                "size": 18667,
                "upload_time": "2022-12-11T09:48:21",
                "upload_time_iso_8601": "2022-12-11T09:48:21.160687Z",
                "url": "https://files.pythonhosted.org/packages/91/43/29b274a3e8a86ee54a083aa69dd5fd859dede4ad7b44412a69cb958696ca/num7-1.0.15.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}