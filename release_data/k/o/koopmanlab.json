{
    "1.0.0": {
        "info": {
            "author": "Wei Xiong, Tian Yang",
            "author_email": "xiongw21@mails.tsinghua.edu.cn",
            "bugtrack_url": null,
            "classifiers": [
                "License :: OSI Approved :: GNU General Public License v3 (GPLv3)",
                "Operating System :: OS Independent",
                "Programming Language :: Python :: 3"
            ],
            "description": "# KoopmanLab\nThe fundamental package for Koopman Neural Operator with Pytorch.\n\n# Installation\nKoopmanLab requires the following dependencies to be installed:\n- PyTorch >= 1.10\n- Numpy >= 1.23.2\n- Matplotlib >= 3.3.2\n\nThen you can install KoopmanLab package:\n\n- Install the stable version with `pip`:\n\n```\n$ pip install koopmanlab\n```\n\n- Install the current version by source code with `pip`:\n```\n$ git clone https://github.com/Koopman-Laboratory/KoopmanLab.git\n$ cd KoopmanLab\n$ pip install -e .\n```\n\n# Usage\nYou can read `demo_ns.py` to familiar with the basic API and workflow of our pacakge. If you want to run `demo_ns.py`, the data need to be prepared in your computing resource.\n- [Dataset](https://drive.google.com/drive/folders/1UnbQh2WWc6knEHbLn-ZaXrKUZhp7pjt-)\n\nIf you want to generation Navier-Stokes Equation data by yourself, the data generation configuration file can be found in the link.\n\n- [File](https://github.com/zongyi-li/fourier_neural_operator/tree/master/data_generation/navier_stokes)\n\nOur package gives you an easy way to create a koopman model.\n``` python\nimport koopmanlab as kp\nMLP_KNO_2D = kp.model.koopman(backbone = \"KNO2d\", autoencoder = \"MLP\", device = device)\nMLP_KNO_2D = kp.model.koopman(backbone = \"KNO2d\", autoencoder = \"MLP\", o = o, m = m, r = r, t_in = 10, device = device)\nMLP_KNO_2D.compile()\n## Parameter definitions:\n# o: the dimension of the learned Koopman operator\n# f: the number of frequency modes below frequency truncation threshold\n# r: the power of the Koopman operator\n# T_in: the duration length of input data\n\nViT_KNO = kp.model.koopman_vit(decoder = \"MLP\", resolution=(64, 64), patch_size=(2, 2),\n            in_chans=1, out_chans=1, head_num=16, embed_dim=768, depth = 16, parallel = True, high_freq = True, device=device)\nViT_KNO.compile()\n## Parameter definitions:\n# depth: the depth of each head \n# head_num: the number of heads\n# resolution: the spatial resolution of input data\n# patch_size: the size of each patch (i.e., token)\n# in_chans:\n# out_chans:\n# num_blocks:\n# embed_dim: \n# parallel: if data parallel is applied\n# high_freq: if high-frequency information complement is applied\n```\nIf you use burgers equation and navier-stokes equation data by the link or shallow water data by PDEBench, there are three specifc data interface are provided.\n``` python\ntrain_loader, test_loader = kp.data.burgers(path, batch_size = 64, sub = 32)\ntrain_loader, test_loader = kp.data.shallow_water(path, batch_size = 5, T_in = 10, T_out = 40, sub = 1)\ntrain_loader, test_loader = kp.data.navier_stokes(path, batch_size = 10, T_in = 10, T_out = 40, type = \"1e-3\", sub = 1)\n## Parameter definitions:\n# path: the file path of the downloaded data set\n# T_in: the duration length of input data\n# T_out: the duration length required to predict\n# Type: the viscosity coefficient of navier-stokes equation data set.\n# sub: the down-sampling scaling factor. For instance, a scaling factor sub=2 acting on a 2-dimensional data with the spatial resoluion 64*64 will create a down-sampled space of 32*32. The same factor action on a 1 dimensional data with the spatial resoluion 1*64 implies a down-sampled space of 1*32.\n```\nWe recommend you process your data by pytorch method `torch.utils.data.DataLoader`. In KNO model, the shape of 2D input data is `[batchsize, x, y, t_len]`, the shape of output data and label is `[batchsize, x, y, T]`, where t_len is defined in `kp.model.koopman` and T is defined in train module. In Koopman-ViT model, the shape of 2D input data is `[batchsize, in_chans, x, y]`, the shape of output data and label is `[batchsize, out_chans, x, y]`.\n\nIn KNO model, The package provides two train methods and two test methods. If your scenario is single step prediction, you'd better use `train_single` method or use `train` setting `T_out = 1`. The package provides prediction result saving method and result ploting method in `test`.\n``` python\nMLP_KNO_2D.train_single(epochs=ep, trainloader = train_loader, evalloader = eval_loader)\nMLP_KNO_2D.train(epochs=ep, trainloader = train_loader, evalloader = eval_loader, T_out = T)\nMLP_KNO_2D.test_single(test_loader)\nMLP_KNO_2D.test(test_loader, T_out = T, path = \"./fig/ns_time_error_1e-4/\", is_save = True, is_plot = True)\n```\nIn Koopman-Vit model, `train` and `test` method for training and testing the model in single step predicition scenario. Because of Koopman-ViT structure, `train_multi` and `test_multi` method provide multi-step iteration prediction, which meanse the model is iterated by `T_out` times in training and testing method. \n``` python\nViT_KNO.train_single(epochs=ep, trainloader = train_loader, evalloader = eval_loader)\nViT_KNO.test_single(test_loader)\nViT_KNO.train_multi(epochs=ep, trainloader = train_loader, evalloader = eval_loader, T_out = T_out)\nViT_KNO.test_multi(test_loader)\n## Parameter definitions:\n# epoch: epoch number of training\n# trainloader: dataloader of training, which is returning variable from torch.utils.data.DataLoader\n# evalloader: dataloader of evaluating, which is returning variable from torch.utils.data.DataLoader\n# test_loader: dataloader of testing, which is returning variable from torch.utils.data.DataLoader\n# T_out: the duration length required to predict\n```\nHaving trained your own model, save module is provided in our package. Saved variable has three attribute. `koopman` is the model class variable, which means save `kno_model` variable. `model` is the trained model variable, which means save `kno_model.kernel` variable. `model_params` is the parameters dictionary of trained model variable, which means `kno_model.kernel.state_dict()` variable.\n``` python\nMLP_KNO_2D.save(save_path)\n## Parameter definitions:\n# save_path: the file path of the result saving\n```\n# Cite KoopmanLab\nIf you use KoopmanLab package for academic research, you are encouraged to cite the following paper:\n```\n\n```\n\n\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/Koopman-Laboratory/KoopmanLab",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "koopmanlab",
            "package_url": "https://pypi.org/project/koopmanlab/",
            "platform": null,
            "project_url": "https://pypi.org/project/koopmanlab/",
            "project_urls": {
                "Homepage": "https://github.com/Koopman-Laboratory/KoopmanLab"
            },
            "release_url": "https://pypi.org/project/koopmanlab/1.0.0/",
            "requires_dist": [
                "torch (>=1.10)",
                "torchvision (>=0.13.1)",
                "matplotlib (>=3.3.2)",
                "numpy (>=1.14.5)",
                "einops (==0.5.0)",
                "timm (==0.6.11)",
                "scipy (==1.7.3)",
                "h5py (==3.7.0)"
            ],
            "requires_python": ">=3.8.5",
            "summary": "A library for Koopman Neural Operator with Pytorch",
            "version": "1.0.0",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16277689,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "6b6d5ffed4e59fc98b2a2202fbb45332",
                    "sha256": "b4e8a84fe5ed1e432af603db0ce506e62af32b69b8187d6135bff8b23c047a65"
                },
                "downloads": -1,
                "filename": "koopmanlab-1.0.0-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "6b6d5ffed4e59fc98b2a2202fbb45332",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": ">=3.8.5",
                "size": 26881,
                "upload_time": "2023-01-02T10:01:18",
                "upload_time_iso_8601": "2023-01-02T10:01:18.933197Z",
                "url": "https://files.pythonhosted.org/packages/c5/d6/7fb6a7b1fbd54de3ca0ff41be83db6e2c52152c3325455b77947e740e580/koopmanlab-1.0.0-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            },
            {
                "comment_text": "",
                "digests": {
                    "md5": "248d6d20fd168b2513ff61d5f2648f92",
                    "sha256": "23d8df9801aeea9003045341a53443cd5a9efd9d4af562140cddf07d3871f8e3"
                },
                "downloads": -1,
                "filename": "koopmanlab-1.0.0.tar.gz",
                "has_sig": false,
                "md5_digest": "248d6d20fd168b2513ff61d5f2648f92",
                "packagetype": "sdist",
                "python_version": "source",
                "requires_python": ">=3.8.5",
                "size": 27550,
                "upload_time": "2023-01-02T10:01:21",
                "upload_time_iso_8601": "2023-01-02T10:01:21.231648Z",
                "url": "https://files.pythonhosted.org/packages/2d/2a/c26769a3159b73747c08c9104025d160bbe95973ee5065834550686ba3d1/koopmanlab-1.0.0.tar.gz",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}