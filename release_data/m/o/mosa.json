{
    "0.3.5": {
        "info": {
            "author": "Roberto Gomes de Aguiar Veiga",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/rgaveiga/mosa",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "mosa",
            "package_url": "https://pypi.org/project/mosa/",
            "platform": null,
            "project_url": "https://pypi.org/project/mosa/",
            "project_urls": {
                "Homepage": "https://github.com/rgaveiga/mosa"
            },
            "release_url": "https://pypi.org/project/mosa/0.3.5/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "Multi-objective Simulated Annealing (MOSA) implementation in pure Python.",
            "version": "0.3.5",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16034646,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "d23d76d672a8d1d7d54f089a61788c1d",
                    "sha256": "36096f40c2f19777b8ea78a92f097f0cc5613dcbafe09f5285d3a19d86ab2bfb"
                },
                "downloads": -1,
                "filename": "mosa-0.3.5-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "d23d76d672a8d1d7d54f089a61788c1d",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 14564,
                "upload_time": "2022-10-01T14:02:30",
                "upload_time_iso_8601": "2022-10-01T14:02:30.286244Z",
                "url": "https://files.pythonhosted.org/packages/ee/84/9b51de56da1f83c55399e6ef8b821650842bc8f62445f14c9560ca7521a1/mosa-0.3.5-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.4": {
        "info": {
            "author": "Roberto Gomes de Aguiar Veiga",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [],
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/rgaveiga/mosa",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "mosa",
            "package_url": "https://pypi.org/project/mosa/",
            "platform": null,
            "project_url": "https://pypi.org/project/mosa/",
            "project_urls": {
                "Homepage": "https://github.com/rgaveiga/mosa"
            },
            "release_url": "https://pypi.org/project/mosa/0.4/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "Multi-objective Simulated Annealing (MOSA) implementation in pure Python.",
            "version": "0.4",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16034646,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "9aeb8ef1991f0b5bf58d431bcd9fd577",
                    "sha256": "6508da382260b4441509b9ce04562952d44317a31ced0de2cbd70fb9ba1bdba3"
                },
                "downloads": -1,
                "filename": "mosa-0.4-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "9aeb8ef1991f0b5bf58d431bcd9fd577",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 15209,
                "upload_time": "2022-11-27T21:50:34",
                "upload_time_iso_8601": "2022-11-27T21:50:34.422981Z",
                "url": "https://files.pythonhosted.org/packages/21/69/8e6478763212de2e47863121b78d03be0c86461f44b8ab12e7ff4398a3f6/mosa-0.4-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    },
    "0.4.5": {
        "info": {
            "author": "Roberto Gomes de Aguiar Veiga",
            "author_email": "",
            "bugtrack_url": null,
            "classifiers": [],
            "description": "# Multi-Objective Simulated Annealing (MOSA)\n\nSimulated Annealing (SA) has been initially proposed in [*Optimization by Simulated Annealing*, https://doi.org/10.1126/science.220.4598.671] as an optimization heuristic. Multi-objective Simulated Annealing (MOSA) extends the original, mono-objective SA to approximate the Pareto front in multi-objective optimization problems. A thorough discussion about MOSA and its algorithm variants can be found in [*Multi-objective Simulated Annealing: Principles and Algorithm Variants*, https://doi.org/10.1155/2019/8134674].\n\nIn the following sections, the basic workflow of a MOSA run with this package is briefly described. Jupyter notebooks in the test directory provide usage examples.\n\n## Setting up a MOSA run\n\nFirst, the user has to import the class *Anneal* from the *mosa* module and instantiate it:\n\n```python\nfrom mosa import Anneal\nopt=Anneal()\n```\n\nThen the user assigns values to *Anneal*'s properties that will control the optimization process. These properties are described below:\n\n```\n    population : dictionary, optional\n        A Python dictionary, each key of which contains the data that can be \n        used to achieve an optimized solution to the problem. Default is\n        {\"X\":(-1.0,1.0)}.\n    archive : dictionary\n        A Python dictionary with two keys: \"Solution\", which contains a list of \n        the best solutions to the problem, and \"Values\", which contains a list \n        of the corresponding objective values. It should not be changed manually.\n    restart : logical, optional\n        Whether the optimization process must restart from a previous run (if \n        a checkpoint file is available) or not. Default is True.\n    objective_weights : list, optional\n        A Python list containing weights for the objectives, one per objective.\n        Default is [], which means the same weight (1.0) for all objectives.\n    initial_temperature : double, optional\n        Initial temperature for the Simulated Annealing algorithm. Default \n        value is 1.0.\n    temperature_decrease_factor : double, optional\n        Decrease factor of the temperature during Simulated Annealing. It\n        determines how fast the quench will occur. Default value is 0.9.\n    number_of_temperatures : integer, optional\n        Number of temperatures to be considered in Simulated Annealing.\n        Default is 10.\n    number_of_iterations : integer, optional\n        Number of Monte Carlo iterations per temperature. Default is 1000.\n    archive_size : integer, optional\n        Maximum number of solutions in the archive. Default value is 1000.\n    archive_file : string, optional\n        Text file where the archive should be saved to. Default value is\n        'archive.json'.\n    maximum_archive_rejections : integer, optional\n        Maximum number of consecutive rejections of insertion of a solution \n        in the archive. Once reached, the optimization process finishes.\n        Default value is 1000.\n    alpha : float, optional\n        Value of the alpha parameter. Default value is 0.0.\n    number_of_solution_elements : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        set and specifies the number of elements for that key in the solution \n        set. Default value is {}, which means one element for all keys in the \n        solution.\n    maximum_number_of_solution_elements : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        set and specifies the maximum number of elements for that key in the \n        solution set, if the number of elements is variable. Default value is \n        {}, which means an unlimited number of elements can be present in the \n        solution keys.\n    no_repeated_elements : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        set and specifies whether an element cannot be repeated in the solution. \n        Default value is {}, which means that repetitions are allowed.\n    mc_step_size : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        and specifies the maximum number of steps, to the left or to the right, \n        that the Monte Carlo algorithm can take when randomly selecting an \n        element in the corresponding key in the population to insert in the \n        solution. Default is {}, which means 0.1 for continuous search \n        spaces and half the number of elements in the population for discrete \n        search spaces.\n    change_value_move : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        set and specifies the weight (non-normalized probability) used to select\n        a trial move in which the value of a randomly selected element in the \n        solution set will be modified. How this modification is done depends on \n        the sample space of solutions to the problem: (1) if discrete, the \n        exchange of values between the solution and the population; or (2) if \n        continuous, the random increment/decrement of the value of an element \n        in the solution set. Default value is {}, which means the weight to \n        select this trial move is equal to 1.0.\n    insert_or_delete_move : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        set and specifies the weight (non-normalized probability) used to \n        select a trial move in which an element will be inserted into or deleted \n        from the solution set. Default value is {}, which means this trial move \n        is not allowed, i.e., weight equal to zero.\n    swap_move : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        set and specifies the weight (non-normalized probability) used to \n        select a trial move in which the algorithm swaps two randomly chosen \n        elements in the solution set. Default value is {}, which means this \n        trial move is not allowed, i.e., weight equal to zero.\n    sort_solution_elements : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        set and specifies if the list in that key must be sorted in ascending \n        order. Default is {}, which means no sorting at all.\n    solution_key_selection_weights : dictionary, optional\n        A Python dictionary where each key corresponds to a key in the solution \n        set and specifies the selection weight of this key in a Monte Carlo \n        iteration. Default value is {}, which means that all keys have the same \n        selection weight, i.e., the same probability of being selected.\n    track_optimization_progress : boolean, optional\n        Wheter to track or not optimization progress by saving the accepted \n        objetive values into a Python list. Default is False.\n    accepted_objective_values : list, readonly\n        A Python list of accepted objective values over Monte Carlo algorithm \n        iterations, useful for diagnostic purposes or for tracking optimization \n        progress.\n```\n\n## Problem definition\n\nThe very first step is to provide a Python dictionary, the *population*, from which the solutions will be sampled. For example, the population of the *alloy_optimization* problem in the test directory is defined as follows:\n\n```python\nopt.population={\"Component\":Component.tolist(),\"Concentration\":(0.0,0.1)}\n```\n\nIn the *population* dictionary above, the \"Component\" key is filled with data obtained from a *numpy* array converted to a Python list. If a key in the population contains a Python list, the corresponding key in the solutions can only contain elements taken from this list. Therefore, the sample space represented by the key is **discrete**. \n\nOn the other hand, the value in the \"Concentration\" key is a Python tuple with two numbers, the lower and upper bounds of a **continuous** sample space. This indicates that the corresponding key in the solutions consists of a list that contains one or more float numbers randomly chosen within the lower and upper bounds.\n\nSubsequently, the user must implement a Python function that takes as its single argument a trial solution to the problem and returns the resulting objective values:\n\n```python\ndef fobj(solution):\n    '''\n    The problem is implemented here. User-defined operations are carried out using \n    the solution as input. f1 and f2, the return values, are the values of the \n    objectives.\n    '''\n    return f1,f2\n```\n\nSee the problems in the test directory for examples on how to implement such a function. Remember that the solution must also be a dictionary with the same keys as the population.\n\n## Running MOSA\n\nThe MOSA algorithm itself is contained in the *evolve* method, which must be called taking as its single argument the function where the user implemented the problem. For example:\n\n```python\nopt.evolve(fobj)\n```\n\nThat is all.\n\n## Pruning dominated solutions\n\nThe best solutions are stored into a Python dictionary, the **archive**. However, at the end of a MOSA run, dominated solutions may still remain in the archive. The *prunedominated* method can be used to get rid of them, returning a version of the archive with only non-dominated solutions:\n\n```\n    prunedominated(xset,delduplicated) -> returns a subset of the full or \n    reduced archive that contains only non-dominated solutions.\n\n    Parameters\n    ----------\n    xset : dictionary, optional\n        A Python dictionary containing the full solution archive or a \n        reduced solution archive. The default is {}, meaning the full solution \n        archive.\n    delduplicated : logical, optional\n        Whether to delete or not a solution if the objective values are \n        strictly equal to the values of a previous solution. The default \n        is False.\n\n    Returns\n    -------\n    tmpdict : dictionary\n        A Python dictionary representing the solution archive with only\n        the solutions that are non-dominated.\n```\n\n## Output\n\nThe *mosa* module provides methods to display the solutions saved in the archive (*printx*), as well as to plot the Pareto front (*plotfront*). Moreover, basic statistics (minimum, maximum and average objective values) can also be shown on screen by using the *printstats* method.\n\n```\n    printx(xset) -> prints the solutions in the archive (complete or \n    reduced) in a more human readable format.\n\n    Parameters\n    ----------\n    xset : dictionary, optional\n        A Python dictionary containing the full solution archive or a \n        reduced solution archive. The default is {}, meaning the full solution \n        archive.\n\n    Returns\n    -------\n    None.\n```\n\n```\n    plotfront(xset,index1,index2) -> plots 2D scatter plots of selected \n    pairs of objective values.\n\n    Parameters\n    ----------\n    xset : dictionary, optional\n        A Python dictionary containing the full solution archive or a \n        reduced solution archive. The default is {}, meaning the full solution \n        archive.\n    index1 : integer, optional\n        Index of the objective function the value of which will be \n        displayed along x-axis. The default is 0.\n    index2 : integer, optional\n        Index of the objective function the value of which will be \n        displayed along y-axis. The default is 1.\n\n    Returns\n    -------\n    None.\n```\n\n```\n    printstats(xset) -> prints the minimum, maximum and average values of \n    the objectives.\n\n    Parameters\n    ----------\n    xset : dictionary, optional\n        A Python dictionary containing the full solution archive or a \n        reduced solution archive. The default is {}, meaning the full \n        solution archive.\n\n    Returns\n    -------\n    None.\n```\n\n## Decision-making\n\nThe module also provides two methods that allow the user to reduce the amount of optimal solutions according to his/her needs, in order to decide which one will be selected:\n\n```\n    trimx(xset,thresholds) -> extracts from the archive the solutions the \n    objective values are less than the given threshold values.\n\n    Parameters\n    ----------\n    xset : dictionary, optional\n        A Python dictionary containing the full solution archive or a \n        reduced solution archive. The default is {}, meaning the full solution \n        archive.\n    thresholds : list, optional\n        Maximum values of the objective funcions required for a solution\n        to be selected. The default is an empty list.\n\n    Returns\n    -------\n    tmpdict : dictionary\n        A Python dictionary representing the solution archive with only\n        the solutions that are in agreement with the thresholds.\n```\n\n```\n    reducex(xset,index,nel) -> reduces and sorts in ascending order the \n    archive according to the selected objective function.        \n\n    Parameters\n    ----------\n    xset : dictionary, optional\n        A Python dictionary containing the full solution archive or a \n        reduced solution archive. The default is {}, meaning the full \n        solution archive.\n    index : integer, optional\n        Index of the objective function that will be used when comparing \n        solutions that will be sorted and introduced in the reduced \n        solution archive. The default is 0.\n    nel : integer, optional\n        Number of solutions stored in the reduced archive. The default is 5.\n\n    Returns\n    -------\n    tmpdict : dictionary\n        A Python dictionary representing the reduced solution archive.\n```\n\n## Saving, loading, copying and merging solution archives\n\nThe full solution archive is saved from times to times during the optimization process into a JSON file (default is *archive.json*, see the *archive_file* property above). There is a method, *savex*, that allows the user to save a solution archive, e.g., a reduced archive, also in the JSON format. Another method, *loadx*, can be used to load the full solution archive from a JSON file. The *copyx* method can be used to copy a solution archive. Finally, two or more solution archives from different MOSA runs can be merged into a single solution archive using the *mergex* method, which provides a simple way to run MOSA in parallel.\n\n```\n    savex(xset,archivefile) -> saves the archive into a text file in JSON \n    format.\n\n    Parameters\n    ----------\n    xset : dictionary, optional\n        A Python dictionary containing the full solution archive or a \n        reduced solution archive. Default is {}, meaning the full solution \n        archive.\n    archivefile : string, optional\n        Name of the archive file. Default is '', which means the main \n        archive file.\n\n    Returns\n    -------\n    None.\n```\n\n```\n    loadx(archivefile) -> loads solutions from a JSON file into the archive.\n\n    Parameters\n    ----------\n    archivefile : string, optional\n        Name of the archive file. Default is '', which means the main \n        archive file will be used.\n\n    Returns\n    -------\n    None.\n```\n\n```\n    copyx(xset) -> returns a copy of archive.\n\n    Parameters\n    ----------\n    xset : dictionary, optional\n        A Python dictionary containing the full solution archive or a \n        reduced solution archive. The default is {}, meaning the full \n        solution archive.\n\n    Returns\n    -------\n    None.\n```\n\n```\n    mergex(xsetlist) -> merges a list of solution archives into a single \n    solution archive.        \n\n    Parameters\n    ----------\n    xsetlist : list\n        A Python list containing the solution archives to be merged.\n\n    Returns\n    -------\n    tmpdict : dictionary\n        A Python dictionary containing the merged solution archives.\n```\n\n## Need to say that...\n\n... the *mosa* module is a pure Python implementation of the MOSA algorithm. As such, one should not expect it to rival, for example, C/C++ implementations in terms of performance. On the other hand, by dealing with Python dictionaries with meaningful names rather than cryptic arrays, *mosa* provides a much more descriptive data model, which also facilitates the data analysis and decision-making process. The current version uses Python lists to store data. Perhaps replacing them with *numpy* arrays and using *numpy* functions in a vectorized fashion can add a few milliseconds to the speed of execution. But that's for future versions.\n\nFinally, the code is provided as is. The author makes no guarantee that its results are accurate and is not responsible for any losses caused by the use of the code. If you have any questions, comments or suggestions about the code, just [drop a message](mailto:roberto.veiga@ufabc.edu.br).\n\n\n",
            "description_content_type": "text/markdown",
            "docs_url": null,
            "download_url": "",
            "downloads": {
                "last_day": -1,
                "last_month": -1,
                "last_week": -1
            },
            "home_page": "https://github.com/rgaveiga/mosa",
            "keywords": "",
            "license": "",
            "maintainer": "",
            "maintainer_email": "",
            "name": "mosa",
            "package_url": "https://pypi.org/project/mosa/",
            "platform": null,
            "project_url": "https://pypi.org/project/mosa/",
            "project_urls": {
                "Homepage": "https://github.com/rgaveiga/mosa"
            },
            "release_url": "https://pypi.org/project/mosa/0.4.5/",
            "requires_dist": null,
            "requires_python": "",
            "summary": "Multi-objective Simulated Annealing (MOSA) implementation in pure Python.",
            "version": "0.4.5",
            "yanked": false,
            "yanked_reason": null
        },
        "last_serial": 16034646,
        "urls": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "5b14adb0472a4a6112b47aff5e11777d",
                    "sha256": "3d2a7d4e1b48c5e38c207fae6d04bfaffd5056ac6406b4c18753977ea6e3619b"
                },
                "downloads": -1,
                "filename": "mosa-0.4.5-py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "5b14adb0472a4a6112b47aff5e11777d",
                "packagetype": "bdist_wheel",
                "python_version": "py3",
                "requires_python": null,
                "size": 15741,
                "upload_time": "2022-12-08T12:50:49",
                "upload_time_iso_8601": "2022-12-08T12:50:49.674883Z",
                "url": "https://files.pythonhosted.org/packages/18/ab/8a3cbf7283e84fc9ce44db02b3a10fe73062740b3209d5dc4683e45ec14c/mosa-0.4.5-py3-none-any.whl",
                "yanked": false,
                "yanked_reason": null
            }
        ],
        "vulnerabilities": []
    }
}